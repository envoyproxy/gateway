// Copyright Envoy Gateway Authors
// SPDX-License-Identifier: Apache-2.0
// The full text of the Apache license is available in the LICENSE file at
// the root of the repo.

package main

import (
	"context"
	"log"
	"net"
	"os"
	"path/filepath"
	"strings"

	core "github.com/envoyproxy/go-control-plane/envoy/config/core/v3"
	tls "github.com/envoyproxy/go-control-plane/envoy/extensions/transport_sockets/tls/v3"
	discovery "github.com/envoyproxy/go-control-plane/envoy/service/discovery/v3"
	secretpb "github.com/envoyproxy/go-control-plane/envoy/service/secret/v3"
	cachetypes "github.com/envoyproxy/go-control-plane/pkg/cache/types"
	cachev3 "github.com/envoyproxy/go-control-plane/pkg/cache/v3"
	resourcev3 "github.com/envoyproxy/go-control-plane/pkg/resource/v3"
	serverv3 "github.com/envoyproxy/go-control-plane/pkg/server/v3"
	"google.golang.org/grpc"
)

const (
	// Unix domain socket path where Envoy expects to reach the SPIRE agent SDS.
	sdsSocketPath = "/var/run/spiffe-workload-api/spire-agent.sock"

	// Name of the SDS secret Envoy will request, from the provided config dump.
	secretName = "spiffe://examples.extensions.io/aws/us-west-2/envoy-proxy"
)

// Fake cert and key for the SDS secret, generated by openssl.
const (
	certPEM = `-----BEGIN CERTIFICATE-----
MIIDIjCCAgqgAwIBAgIBADANBgkqhkiG9w0BAQsFADAtMRUwEwYDVQQKDAxleGFt
cGxlIEluYy4xFDASBgNVBAMMC2V4YW1wbGUuY29tMB4XDTI1MTAwODIwNTgzM1oX
DTI2MTAwODIwNTgzM1owODEXMBUGA1UEAwwOZXhhbXBsZS1jbGllbnQxHTAbBgNV
BAoMFGV4YW1wbGUgb3JnYW5pemF0aW9uMIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8A
MIIBCgKCAQEAoaRkTGVlKCzfM4O3O55RNFeXCalkPGqEBnt1XHEri8Dt5bbcOqEu
OL6N6azRqSaYEz8fg5Hr0tR4atmLxs8UQucqveSFjaNgfRrso00miVlS225o7wXa
VFAnKxQSoLSq3aTqNKxNspMtuakLaOthFS3YI0Z6ifS2A9f35TjDcTXmPJpHpOwY
7s0zEu8bAlA4r9PWXVD9ylkALRfdH9a5T3eqVdrtgUOr4zxsHaD3xXeoyqXHrZE1
8sLKXDomjAwQON3/DckbBV1HqjzbEzDGaZEqiJfzwZwvSG+CNfZA8LAbT1bEYc5h
k//aXVno84bz4G5lRVk2MFwm9Peem86DKQIDAQABo0IwQDAdBgNVHQ4EFgQUrvOn
bEg0O+i1GKIVfiGZX1fJ60IwHwYDVR0jBBgwFoAU36NYY/EuHhdWNE7pzMkQeFww
ZZYwDQYJKoZIhvcNAQELBQADggEBADCbtfynRDO6Sw+LhdenlJdkid921e7NsLeY
jOnyVT53eZB/14rjGqbjLhz8ZfMgtCaAU8EUy48D/Z8RZNaTWtF44WnzpLkxsGw1
ZNoBb6/LKOGSQBTiet3yeWdr0pfofqkFTZtBVXtOKspGSxYbl6zZfn55WKpX6nGE
Tv49JwFAmW6VOjoE0CqJMOSauTSAkWjGXKfVP+zkVXnGC4WSzKisfJYcZsnHx1q+
frSJT0hZdEOrYBwz2OS7XOn9abxwGwHzpF3vhQm9MVC3jU2s1DGjPW3b1y/DJtyg
e+dm0+r5h7zh4X2TA85TJnPFKDhjPd2Opn2wMzjg8HSxCY/Ze2k=
-----END CERTIFICATE-----`
	keyPEM = `-----BEGIN PRIVATE KEY-----
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBKgwggSkAgEAAoIBAQChpGRMZWUoLN8z
g7c7nlE0V5cJqWQ8aoQGe3VccSuLwO3lttw6oS44vo3prNGpJpgTPx+DkevS1Hhq
2YvGzxRC5yq95IWNo2B9GuyjTSaJWVLbbmjvBdpUUCcrFBKgtKrdpOo0rE2yky25
qQto62EVLdgjRnqJ9LYD1/flOMNxNeY8mkek7BjuzTMS7xsCUDiv09ZdUP3KWQAt
F90f1rlPd6pV2u2BQ6vjPGwdoPfFd6jKpcetkTXywspcOiaMDBA43f8NyRsFXUeq
PNsTMMZpkSqIl/PBnC9Ib4I19kDwsBtPVsRhzmGT/9pdWejzhvPgbmVFWTYwXCb0
956bzoMpAgMBAAECggEADDqBk/3/vyBV6nHGhO4fOpR9yq9T8/Yi8tKYOFwfbT01
QjGpS44yDvzrg4gdfGx9CMe3vJ5ndtW4Hm1C09GKuN0AMMl/CQ4ZGJ3W1SvbBH0L
dapOqfaJY+OEcw/bsOi6HHaDeWSnpCDaTrdpM5DLEW0cct68Gn+23WeTS3YV4xSP
/Cvz126xheeJ1OR6/N2nvNzxw3K6WivWz0aZSinigM/CdxddoBMvkDjCu6X0zbaD
lOfRZjZ45D3EbYa/8Tv80d4kz5k2Vd68uzqcCdsDzyVA1F1+dlzAYgrvuO0sXABW
JZMluE/UxjsKeev9IqQHcRUSHz9owGBT831VnFob+QKBgQDVUU8Nub70hWQx9DRv
k7jv6OUMz3KXoDX77ZUKE9ZVzagM2X5WNH4S+t8/ybkJrPXGAwPbDHSd2Q6Zdhnk
kh7o2KFT4KxQd5xqXS5GeenxT1gVqKl9UjFWiOK6To4kJcb4/PxgqUXAvWu3UTbx
Sw/L3PuS5c5IgfEbzK9XVrzJgwKBgQDB/CEyGiKpsvwskskiHrtlj9siWAqBLJr2
dLlsdoNMIfcZxp6lKqbXnyFvbjQePEXshFVIvgiA1BFNvzyUl09BTbPN4yv5lnnJ
D/TnmgxmfqW4XeaswuXnKig15A5OgcLq3ySfpNUyVr47yCmgDgU/gEW8J34fkhEv
GpWsEzSc4wKBgQCDaFc+qVIM569VZo52vZWLlPik75Yz+anHzA+n6Zh7uvjvEXxW
NngD0S996BJo93dfx7O0WPPt2Sy5NJu2xpzr66dWOG1uFIDytPwwxiFrWel1TjU6
0ks6d5DUHFhLxEnSUGZYVW520Tlt8EXcVtUgTL1dPNvaptGUwn6xWulpaQKBgQCI
34AEvBAtMQ9h3AhzPL/5P3HdX8W5s2F7+IxFDbJC68xQsaaK3/dtOOj8mQPJOboU
0qLiesPBMuEqvH7gUYsohs0RvvLuXtB7n/ir2jRZtY708byrtbFGVKaer9Wwazq/
QseypTmRFUeRIwDL4Fivn7CUvEDvwb7CP73P9pUvBQKBgEBtcL0fQPuAK8/737wu
LnT8Aek6RUHX9sk2ruJ675yM5ujMWYj6Q9ovHsgX0BTkJ0aN6hkfRYUlVWRGx0VO
Bbs3oPhPBd+ZxPR+WE5pP1aeUg8Gg0sPBGDgu7sOEG0lR3c2LB/JTaTMAsNWN/TG
nWAf55s/o6BnHTDud+k3HBaa
-----END PRIVATE KEY-----`
)

func requestedSecret(names []string, want string) bool {
	for _, n := range names {
		if strings.TrimSpace(n) == want {
			return true
		}
	}
	return false
}

func buildSecret(name, cert, key string) *tls.Secret {
	// Note: minimal validation to keep example simple.
	if strings.TrimSpace(cert) == "" || strings.TrimSpace(key) == "" {
		log.Printf("warning: cert or key PEM is empty; replace placeholders before use")
	}
	return &tls.Secret{
		Name: name,
		Type: &tls.Secret_TlsCertificate{
			TlsCertificate: &tls.TlsCertificate{
				CertificateChain: &core.DataSource{Specifier: &core.DataSource_InlineString{InlineString: cert}},
				PrivateKey:       &core.DataSource{Specifier: &core.DataSource_InlineString{InlineString: key}},
			},
		},
	}
}

func makeSnapshot(version string, name, cert, key string) (*cachev3.Snapshot, error) {
	resources := map[resourcev3.Type][]cachetypes.Resource{
		resourcev3.SecretType: {buildSecret(name, cert, key)},
	}
	return cachev3.NewSnapshot(version, resources)
}

func main() {
	// Ensure socket directory exists.
	if err := os.MkdirAll(filepath.Dir(sdsSocketPath), 0755); err != nil {
		log.Fatalf("failed to create socket dir: %v", err)
	}

	// Remove stale socket if present.
	if err := os.RemoveAll(sdsSocketPath); err != nil {
		log.Fatalf("failed to remove existing socket: %v", err)
	}

	lis, err := net.Listen("unix", sdsSocketPath)
	if err != nil {
		log.Fatalf("failed to listen on %s: %v", sdsSocketPath, err)
	}

	// Make the socket widely accessible so Envoy (possibly running as another user)
	// can connect via host-mounted path.
	if err := os.Chmod(sdsSocketPath, 0777); err != nil {
		log.Printf("warning: failed to chmod socket: %v", err)
	}

	// Set up go-control-plane snapshot cache + server over the Unix socket.
	xdsCache := cachev3.NewSnapshotCache(false, cachev3.IDHash{}, nil)

	snapshot, err := makeSnapshot("1", secretName, certPEM, keyPEM)
	if err != nil {
		log.Fatalf("failed to create snapshot: %v", err)
	}

	// Install snapshot lazily for each connecting node ID (Envoy sets node.id from pod name).
	callbacks := serverv3.CallbackFuncs{
		StreamRequestFunc: func(streamID int64, req *discovery.DiscoveryRequest) error {
			if req == nil || req.Node == nil || req.Node.Id == "" {
				return nil
			}
			log.Printf("streamRequestFunc: %v", req.Node.Id)
			if _, err := xdsCache.GetSnapshot(req.Node.Id); err == nil {
				return nil
			}
			return xdsCache.SetSnapshot(context.Background(), req.Node.Id, snapshot)
		},
	}

	srv := serverv3.NewServer(context.Background(), xdsCache, callbacks)
	grpcServer := grpc.NewServer()
	secretpb.RegisterSecretDiscoveryServiceServer(grpcServer, srv)

	log.Printf("fake SPIRE SDS server listening on %s, serving secret %q via snapshot cache", sdsSocketPath, secretName)
	if err := grpcServer.Serve(lis); err != nil {
		log.Fatalf("gRPC server error: %v", err)
	}
}
